<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>Firehose Documentation</title>
  <script src='../javascript/application.js'></script>
  <script src='../javascript/search.js'></script>
  <link rel='stylesheet' href='../stylesheets/application.css' type='text/css'>
</head>
  <body>
    <div id='base' data-path='../'></div>
<div id='header'>
  <div id='menu'>
    <a href='../extra/README.md.html' title='Firehose'>
      Firehose
    </a>
    &raquo;
    <a href='../alphabetical_index.html' title='Index'>
      Index
    </a>
    &raquo;
    <span class='title'>README.md</span>
  </div>
</div>
    <div id='content'>
      <nav class='toc'>
        <p class='title'>
          <a class='hide_toc' href='#'>
            <strong>Table of Contents</strong>
          </a>
          <small>
            (<a class='float_toc' href='#'>left</a>)
          </small>
        </p>
      </nav>
      <div id='filecontents'>
        <h1 id="firehose-js">Firehose.js</h1><p>Javascript library for interacting with the Firehose API.</p><h2 id="getting-started">Getting Started</h2><p>Add this to your bower.json file:</p><pre><code>&quot;firehosejs&quot;: &quot;mysterioustrousers/Firehose&quot;
</code></pre><h2 id="documentation">Documentation</h2>
<h3 id="environments">Environments</h3><p>Because Firehose.js is meant to be used in a browser environment, it&#39;s environment is directly tied to the current base URL. It uses the browser&#39;s current URL to figure out what environment it is running in and that, in turn, dictates what api server it talks to, what billing server it talks to, etc. It also means that Firehose.js can be used to generate links to other Firehose clients and the environment will be maintained as the browser navigates to different clients. For example,
consider a link in the brower app:</p><pre><code>&lt;a href=&quot;javascript:Firehose.baseURLFor(&#39;marketing&#39;) + &#39;/home/login&#39;;&quot;&gt;Log In&lt;/a&gt;
</code></pre><p>If you were viewing the browser app in development at <code>http://localhost:4001</code> then the link would be generated as <code>http://localhost:4004/home/login</code>. If the current browser app was running in production at <code>https://firehoseapp.com</code> the linke would be generated as <code>https://getfirehose.com/home/login</code>.</p><h4 id="beta">Beta</h4><p>Every browser client will have a variation of the production hostname, each with a <code>beta.*</code> prefix. This will be used by all of us and any customers who want to use pre-release versions of our browser clients. This only applies to browser clients, there will be no such thing for our server apps (API, billing, frh.io) since they have production data involved. So, for example, <code>https://beta.firehoseapp.com/</code> will be the next version of our browser app that anyone can use (at their own risk) and it will point to production API, billing, frh.io. Firehose.js knows when it&#39;s running in beta because the browser&#39;s url has <code>beta</code> in it. It will talk to production servers, but all links to other browser clients will also be have the beta prefix. So if you&#39;re using the beta browser app, logging out and clicking on the firhose logo will take you to <code>https://beta.getfirehose.com/</code></p><h4 id="port-numbers">Port Numbers</h4><p>On localhost, where you are supplying port numbers, you can modify the different digits of the port number to modify how Firehose.js generates URLs. In production, there are no port numbers, so Firehose.js will use the default expected behavior. The different port number digits represent the following:</p><ul>
<li><p><strong>[1]</strong> The type of service served. Changing this does not actually affect anything at all, it&#39;s just going to be convention that servers will have the first digit of <code>3</code> and browser clients will have the first digit of <code>4</code>. This way, when you look at a URL, you can quickly tell if the url can be visted in a browser or if it&#39;s simply a json server. The API, billing and frh.io URLs have port numbers starting with 3, all the rest start with 4. So When testing the browser client locally, run middleman with <code>middleman -p 4001</code> </p><pre><code>  3: Sever
  4: Client
</code></pre></li>
<li><p><strong>[2]</strong> The server to use. Usually this just needs to be 0, for development. But, sometimes you want to run a client served by middleman locally but have Firehose.js talk to the production server, so you could run the browser app at <code>4201</code> and you&#39;d get a locally running browser client talking to the production API billing <strong>and</strong> servers. In the future, I plan to have all the server apps running on our mac mini colo with each app downloading a copy of the live db regularly. This will mostly be useful for Rob, who can easily run browser clients with middleman, but has a very hard time getting the dev server apps up and running. This would allow him to run the browser clients on his local machine, have them talk to copies of our product apps on the mini colo and be safe from accidental changes to the production db while using an in-dev version
of the browser client.</p><pre><code>  0: development
  1. mini
  2. production
</code></pre></li>
<li><p><strong>[3]</strong> The environment. Because the environment is usually inferred from the hostname, this is an optional override for when you are developing a browser client locally. For example, the test suite of Firehose.js runs on port <code>4011</code> to pose as if it&#39;s the browser app, but pointing to the local server and its test environment. This only makes sense for running in dev or test.</p><pre><code>  0: development
  1: test
</code></pre></li>
<li><p><strong>[4]</strong> The app. Running marketing on port ***1 would change nothing, except that Firehose.js assumes everything is running on it&#39;s designated port. So if the billing app was running on ***7, and you took some action that resulted in the browser app redirecting you to the marketing app, it would try to send you to ***4, because that&#39;s where it assumes it is running. In this scenario of not following the rules, it would say server could not be found because nothing is running at ***4. So, it&#39;s just in your best interest to learn these and run apps locally on the right fourth digit port number.</p><pre><code>  0: API   
  1: browser
  2: billing 
  3: frhio    
  4: marketing 
  5: settings   
  6: tweetlonger 
  7: kb          
</code></pre></li>
</ul>
<h2 id="examples">Examples</h2><p><em>(Coming soon)</em></p><h2 id="contributing">Contributing</h2><p>Make sure you install the following npm packages:</p><pre><code>sudo npm install -g coffeedoc
sudo npm install -g exec
</code></pre><p>Make sure these two env vars are set in your .bash_profile:</p><pre><code>export FH_API_PATH=&#39;/Users/adamkirk/mt/projects/firehose/firehose&#39;
export FH_BILLING_PATH=&#39;/Users/adamkirk/mt/projects/firehose/billing&#39;
</code></pre><p>So that the start_server.sh script knows where your apps are to start them for testing.</p><p>You must also make sure that both your local API and billing apps have <code>rake db:create RAILS_ENV=testclient</code> and <code>rake db:migrate RAILS_ENV=testclient</code></p>
      </div>
    </div>
    <div id='footer'>
  February 08, 14 15:45:17 by
  <a href='https://github.com/coffeedoc/codo' title='CoffeeScript API documentation generator'>
    Codo
  </a>
  2.0.3
  &#10034;
  Press H to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/netzpirat' target='_parent'>@netzpirat</a>
  &#10034;
  <a href='http://twitter.com/_inossidabile' target='_parent'>@_inossidabile</a>
  &#10034;
  <a href='https://mksoft.ch' target='_parent'>mksoft.ch</a>
</div>
<iframe id='search_frame'></iframe>
<div id='fuzzySearch'>
  <input type='text'>
  <ol></ol>
</div>
<div id='help'>
  <p>
    Quickly fuzzy find classes, mixins, methods, file:
  </p>
  <ul>
    <li>
      <span>T</span>
      Open fuzzy finder dialog
    </li>
  </ul>
  <p>
    Control the navigation frame:
  </p>
  <ul>
    <li>
      <span>L</span>
      Toggle list view
    </li>
    <li>
      <span>C</span>
      Show class list
    </li>
    <li>
      <span>I</span>
      Show mixin list
    </li>
    <li>
      <span>F</span>
      Show file list
    </li>
    <li>
      <span>M</span>
      Show method list
    </li>
    <li>
      <span>E</span>
      Show extras list
    </li>
  </ul>
  <p>
    You can focus and blur the search input:
  </p>
  <ul>
    <li>
      <span>S</span>
      Focus search input
    </li>
    <li>
      <span>Esc</span>
      Blur search input
    </li>
  </ul>
</div>
  </body>
</html>